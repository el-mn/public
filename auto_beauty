###########################################
#autoBeauty.py
#Version 1.0.6
#Last updated October 26 2020
#This module allow to import multi passes render from the render engine Cycle
#and Redshift, let the user choose between an additive or a substractive assembly
#and finally reconstruct automaticaly the beauty. There are also denoise and sharpen
#options plus a preview of the selected pass.
###########################################

import nuke



def Render_assembly_choice():

    #----------------------------------------------------
    #Create a panel where the user can choose the type of render engine used,
    #and let him import the file
    #param: None
    #return: render_choice, path_file, assembly_choice
    #----------------------------------------------------

    #Render engine choice menu
    render_list = ["Cycle", "Redshift"]
    render_list_cleaned = " ".join(render_list)

    #Assembly type choice menu
    assembly_type = ["Additive", "Substractive"]
    assembly_type_cleaned = " ".join(assembly_type)

    #List of the passes to use depending the render engine choice, to populate.
    channels_select = []

    #Panel creation
    my_panel = nuke.Panel("AutoBeauty")
    my_panel.addEnumerationPulldown("Render engine", render_list_cleaned)
    my_panel.addEnumerationPulldown("Assembly type", assembly_type_cleaned)
    my_panel.addClipnameSearch("File path", "Choose a file")
    my_panel.show()


    #variables user input
    path_file = my_panel.value("File path")
    render_choice = my_panel.value("Render engine")
    assembly_choice = my_panel.value("Assembly type")
    ##########################
    global assembly_choice  #
    ########################
    global render_choice  #
    ######################


    return render_choice, path_file, assembly_choice







def passes_extraction():
    #--------------------------------------------------
    #Creation of the group, the read node with the render choosen.
    #Extraction of the channels and shuffle each of them .
    #param: None
    #return: channels_to_assembly, assembly_choice, render_choice, my_group, sh_beauty
    #--------------------------------------------------

    render_choice, path_file, assembly_choice = Render_assembly_choice()

    #definition of channels to extract on each render engine
    if render_choice == "Cycle":
        channels_select =  ["DiffDir.red", "DiffInd.red", "DiffCol.red", "GlossDir.red", "GlossInd.red", "GlossCol.red", "TransDir.red", "TransInd.red", "TransCol.red", "Emit.red"]
    elif render_choice == "Redshift":
        channels_select = ["DiffuseFilter.red", "DiffuseLightingRaw.red", "Emission.red", "GIRaw.red","ReflectionsFilter.red", "ReflectionsRaw.red", "RefractionsFilter.red", "RefractionsRaw.red", "SpecularLighting.red" ]

    #Group creation
    my_group = nuke.nodes.Group(name= "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)
    my_group["tile_color"].setValue(5608959)
    my_group.begin()

    #ReadNode creation with render file path set up
    readFile= nuke.nodes.Read(name = "render", xpos = 0, ypos = 0)
    readFile["file"].setValue(path_file)
    readFile_Ypos = nuke.toNode("render")["ypos"].value()
    readFile_Xpos = nuke.toNode("render")["xpos"].value()

    #channels extraction from the file
    channels_extraction = readFile.channels()
    channels_to_assembly = list(set([chan.split(".")[0]for chan in channels_extraction if chan in channels_select]))
    channels_to_assembly.sort()
    ###############################
    global channels_to_assembly  #
    ##############################


    #Beauty pass reference for QC
    for chan in channels_extraction:
        if chan == "rgba.red":
            sh_beauty = nuke.nodes.Shuffle(name = "Beauty ref", xpos = 2000, ypos = 0)
            sh_beauty.setInput(0,readFile)
            sh_beauty.knob("in").setValue(chan[:4])



    #-------------------------------------------------------------------
    #Split the read file into all the passes
    #-------------------------------------------------------------------
    pos_sh = 340
    for chan in channels_to_assembly:


        #Passes extraction, creation of shuffles and a remove node
        sh = nuke.nodes.Shuffle(name = chan, xpos = pos_sh, ypos = 200)
        sh.setInput(0,readFile)
        nuke.toNode(chan).knob("in").setValue(chan)
        nuke.toNode(chan).knob("in2").setValue("alpha")
        nuke.toNode(chan).knob("alpha").setValue("red2")

        keep = nuke.nodes.Remove(name = "Keep "+chan, xpos = pos_sh, ypos = 300)
        keep.setInput(0, sh)
        keep["operation"].setValue("keep")
        keep["channels"].setValue("rgb")
        keep["channels2"].setValue("alpha")
        pos_sh -= 85



    return channels_to_assembly, assembly_choice, render_choice, my_group, sh_beauty







def pre_treatment():
    #--------------------------------------------------
    #param: None
    #Creation of the differents tabs of the group and the nodes associated to those tabs
    #return: channels_to_assembly, assembly_choice, render_choice, my_group, sh_beauty
    #--------------------------------------------------

    channels_to_assembly, assembly_choice, render_choice, my_group, sh_beauty = passes_extraction()

    #---------------------------------------------------------------------------
    #definition of each passes for each render engine (Cycle and Redshift)
    #---------------------------------------------------------------------------
    if render_choice == "Cycle":
        pass_naming = ["Diffuse color", "Diffuse direct", "Diffuse indirect", "Emission", "Glossy color", "Glossy direct", "Glossy indirect", "Transmission color", "Transmission direct", "Transmission indirect"]
    else:
        pass_naming = ["Diffuse filter", "Diffuse lighting raw", "Emission", "GI raw", "Reflections filter", "Reflections raw", "Refractions filter", "Refractions raw", "Specular"]




    #---------------------------------------------------------------------------
    #Tabs with knobs creation on group
    #---------------------------------------------------------------------------


    #-----------------------
    #Denoise/ sharpen tab
    #-----------------------
    tab_denoise = nuke.Tab_Knob("Denoise/ Sharpen")
    my_group.addKnob(tab_denoise)
    pass_selection = nuke.Enumeration_Knob("par_pass_select_denoise", "Pass to preview", channels_to_assembly)
    my_group.addKnob(pass_selection)

    show_pass_den = nuke.PyScript_Knob("par_show_pass_den", "Preview pass", "autoBeauty_v108.show_pass()")
    my_group.addKnob(show_pass_den)
    show_beauty_recon = nuke.PyScript_Knob("par_show_beauty_recon", "Back to beauty", "autoBeauty_v108.show_beauty()")
    my_group.addKnob(show_beauty_recon)
    my_group["par_show_pass_den"].setFlag(nuke.STARTLINE)

    i = 0
    for chan in channels_to_assembly:
        divider_channels = nuke.Text_Knob((pass_naming[i]).upper())
        my_group.addKnob(divider_channels)
        on_off = nuke.Boolean_Knob("par_onOff_den_"+render_choice+"_"+assembly_choice+"_"+chan, "Enable denoise", False)
        my_group.addKnob(on_off)
        my_group["par_onOff_den_"+render_choice+"_"+assembly_choice+"_"+chan].setFlag(nuke.STARTLINE)
        region = nuke.BBox_Knob("par_reg_analys_"+render_choice+"_"+assembly_choice+"_"+chan, "Region analysis")
        my_group.addKnob(region)
        my_group["par_reg_analys_"+render_choice+"_"+assembly_choice+"_"+chan].setValue((950, 510, 1060, 615))
        analysis_noise = nuke.PyScript_Knob("par_analysis_den_"+render_choice+"_"+assembly_choice+"_"+chan, "Analyze noise", "autoBeauty_v108.analyze_noise_execution()")
        my_group.addKnob(analysis_noise)
        den_amount = nuke.Double_Knob("par_den_amount_"+render_choice+"_"+assembly_choice+"_"+chan, "Amount")
        my_group.addKnob(den_amount)
        my_group["par_den_amount_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(1)


        on_off_sharpen = nuke.Boolean_Knob("par_onOff_sharp_"+render_choice+"_"+assembly_choice+"_"+chan, "Enable sharpen", False)
        my_group.addKnob(on_off_sharpen)
        my_group["par_onOff_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setFlag(nuke.STARTLINE)
        minimum_amount = nuke.Double_Knob("par_min_sharp_"+render_choice+"_"+assembly_choice+"_"+chan, "Minimum")
        my_group.addKnob(minimum_amount)
        maximum_amount = nuke.Double_Knob("par_max_sharp_"+render_choice+"_"+assembly_choice+"_"+chan, "Maximum")
        my_group.addKnob(maximum_amount)
        my_group["par_max_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(1)
        sharpen_amount = nuke.Double_Knob("par_sharp_amount_"+render_choice+"_"+assembly_choice+"_"+chan, "Amount")
        my_group.addKnob(sharpen_amount)
        my_group["par_sharp_amount_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(1)
        size_amount = nuke.Double_Knob("par_size_sharp_"+render_choice+"_"+assembly_choice+"_"+chan, "Size")
        my_group.addKnob(size_amount)
        my_group["par_size_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(3)
        i += 1




    #-----------------------
    #QC tab
    #-----------------------
    tab_qc = nuke.Tab_Knob("QC")
    my_group.addKnob(tab_qc)
    divider_qc = nuke.Text_Knob("If checked, this will difference the original beauty with the reconstruted one")
    my_group.addKnob(divider_qc)
    qc_checker = nuke.Boolean_Knob("par_qc_check_"+render_choice+"_"+assembly_choice, "QC check", False)
    my_group.addKnob(qc_checker)
    my_group["par_qc_check_"+render_choice+"_"+assembly_choice].setFlag(nuke.STARTLINE)




    #-----------------------
    #Grading tab
    #-----------------------
    tab_grade = nuke.Tab_Knob("Grading")
    my_group.addKnob(tab_grade)

    i = 0
    for chan in channels_to_assembly:

        divider = nuke.Text_Knob((pass_naming[i]).upper())
        my_group.addKnob(divider)
        b_point = nuke.Color_Knob("par_b_point_"+render_choice+"_"+assembly_choice+"_"+chan, "Blackpoint")
        b_point.setRange(-1,1)
        my_group.addKnob(b_point)
        my_group["par_b_point_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(0)
        w_point = nuke.Color_Knob("par_w_point_"+render_choice+"_"+assembly_choice+"_"+chan, "Whitepoint")
        w_point.setRange(-1,4)
        my_group.addKnob(w_point)
        my_group["par_w_point_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(1)
        lift = nuke.Color_Knob("par_lift_"+render_choice+"_"+assembly_choice+"_"+chan, "Lift")
        lift.setRange(-1,1)
        my_group.addKnob(lift)
        my_group["par_lift_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(0)
        gain = nuke.Color_Knob("par_gain_"+render_choice+"_"+assembly_choice+"_"+chan, "Gain")
        gain.setRange(0,4)
        my_group.addKnob(gain)
        my_group["par_gain_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(1)
        multiply = nuke.Color_Knob("par_multiply_"+render_choice+"_"+assembly_choice+"_"+chan, "Multiply")
        multiply.setRange(0,4)
        my_group.addKnob(multiply)
        my_group["par_multiply_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(1)
        offset = nuke.Color_Knob("par_offset_"+render_choice+"_"+assembly_choice+"_"+chan, "Offset")
        offset.setRange(-1,1)
        my_group.addKnob(offset)
        my_group["par_offset_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(0)
        gamma = nuke.Color_Knob("par_gamma_"+render_choice+"_"+assembly_choice+"_"+chan, "Gamma")
        gamma.setRange(0,5)
        my_group.addKnob(gamma)
        my_group["par_gamma_"+render_choice+"_"+assembly_choice+"_"+chan].setValue(1)
        i += 1



###############################################################
####################### knob changed ##########################
###############################################################

    nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice).knob("knobChanged").setValue("autoBeauty_v108.visibility()")

################################################################
######################## knob changed #########################
###############################################################


    pos_denoiser, pos_colorSpace1, pos_sharpen = 340, 340, 340
    pos_splitSh = 1490

    for chan in channels_to_assembly:

        #Creation of denoisers on each passes
        denoiser_pass = nuke.nodes.Denoise2(name = "Denoise "+chan, xpos = pos_denoiser, ypos = 400)
        denoiser_pass.setInput(0,nuke.toNode("Keep "+chan))

        exp_den_onOff = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_onOff_den_"+render_choice+"_"+assembly_choice+"_"+chan+"-1"
        denoiser_pass["disable"].setExpression(exp_den_onOff)
        exp_den_analysis = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_reg_analys_"+render_choice+"_"+assembly_choice+"_"+chan
        denoiser_pass["analysisRegion"].setExpression(exp_den_analysis)
        exp_den_amount = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_den_amount_"+render_choice+"_"+assembly_choice+"_"+chan
        denoiser_pass["amount"].setExpression(exp_den_amount)
        pos_denoiser -= 85


        #Colorspace change, linear to YCbCr
        colorSpace1 = nuke.nodes.Colorspace(name = chan+"\ncolorspace in", xpos = pos_colorSpace1, ypos = 600)
        colorSpace1.setInput(0,denoiser_pass)
        colorSpace1["colorspace_out"].setValue("YCbCr")
        colorSpace1["label"].setValue("[value colorspace_in]"+"\nto"+"\n[value colorspace_out]")
        pos_colorSpace1 -= 85


        #Definition of naming for incoming shuffles
        x = ["Y", "Cb", "Cr"]
        y = ["red", "green", "blue", "alpha"]
        z = {"red": ["red", "black", "black", "black"], "green" : ["black", "green", "black", "black"], "blue": ["black", "black", "blue", "black"]}
        a = 0
        b = 0
        for i in range(3):
            #Creation of shuffles. They split each pass in Y, Cb and Cr respectively on the channels Red,Green and Blue
            splitSh = nuke.nodes.Shuffle(name = chan +" "+x[i], xpos = pos_splitSh, ypos = 800)
            splitSh.setInput(0,nuke.toNode(chan+"\ncolorspace in"))
            splitSh[y[b]].setValue(z[y[i]][a])
            splitSh[y[b+1]].setValue(z[y[i]][a+1])
            splitSh[y[b+2]].setValue(z[y[i]][a+2])
            splitSh["in2"].setValue("alpha")
            splitSh[y[b+3]].setValue("red2")
            pos_splitSh -= 115


            if i == 0:
                #Creation of sharpen node only on the Y channel
                sharpen = nuke.nodes.Sharpen(name = chan+" Y_Sharpen", xpos = (splitSh.knob("xpos").value()), ypos = 850)
                sharpen.setInput(0,splitSh)
                sharpen["disable"].setValue(True)
                expression_sharpen_onOff = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_onOff_sharp_"+render_choice+"_"+assembly_choice+"_"+chan+"-1"
                sharpen["disable"].setExpression(expression_sharpen_onOff)
                expression_sharpen_min = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_min_sharp_"+render_choice+"_"+assembly_choice+"_"+chan
                sharpen["minimum"].setExpression(expression_sharpen_min)
                expression_sharpen_max = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_max_sharp_"+render_choice+"_"+assembly_choice+"_"+chan
                sharpen["maximum"].setExpression(expression_sharpen_max)
                expression_sharpen_amount = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_sharp_amount_"+render_choice+"_"+assembly_choice+"_"+chan
                sharpen["amount"].setExpression(expression_sharpen_amount)
                expression_sharpen_size = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_size_sharp_"+render_choice+"_"+assembly_choice+"_"+chan
                sharpen["size"].setExpression(expression_sharpen_size)


        #Reassembly Luma and chroma with merge creation
        m = nuke.nodes.Merge2(label = chan, xpos = (sharpen.knob("xpos").value()), ypos = +950)
        m["operation"].setValue("plus")
        m.setInput(0,sharpen)
        m.setInput(1,nuke.toNode(chan +" "+x[1]))
        m.setInput(3,nuke.toNode(chan +" "+x[2]))

        #Creation of a clamp for the alpha
        cl = nuke.nodes.Clamp(name = "clamp alpha"+chan, xpos = (sharpen.knob("xpos").value()), ypos = +1000)
        cl["channels"].setValue("alpha")
        cl.setInput(0, m)

        #move back to linear from YCbCr
        colorSpace2 = nuke.nodes.Colorspace(name = chan+"\ncolorspace out", label = "[value colorspace_in]"+"\nto"+"\n[value colorspace_out]", xpos = (m.knob("xpos").value()), ypos = 1100)
        colorSpace2["colorspace_in"].setValue("YCbCr")
        colorSpace2.setInput(0,cl)

        #Dot with name of each pass creation
        dot = nuke.nodes.Dot(name = "Dot "+chan, label = chan, xpos = (colorSpace2.knob("xpos").value()+34), ypos = 1250)
        dot.setInput(0,colorSpace2)

        #Text node for pass visualization
        txt = nuke.nodes.Text2( name = "text_channel_display "+chan, xpos = (dot.knob("xpos").value()+65), ypos = 1270)
        txt.setInput(0, dot)
        txt["box"].setValue((20, 40, 1000, 130))
        txt["font"].setValue("Bahnschrift", "Regular")
        txt["global_font_scale"].setValue(0.2)
        #txt["tracking"].setValue(float(0.1))
        txt["message"].setValue(chan.upper())



    return channels_to_assembly, assembly_choice, render_choice, my_group, sh_beauty







def assembly():
    #--------------------------------------------------
    #Call the right function depending of the render choice by the user
    #param: None
    #return: channels_to_assembly, assembly_choice, render_choice, my_group, main_channels
    #--------------------------------------------------

    channels_to_assembly, assembly_choice, render_choice, my_group, sh_beauty = pre_treatment()


    if render_choice == "Cycle":

        main_channels = cycle(assembly_choice, render_choice)

    elif render_choice == "Redshift":

        main_channels = redshift(assembly_choice, render_choice)


    return channels_to_assembly, assembly_choice, render_choice, my_group, sh_beauty, main_channels







def auto_beauty():
    #--------------------------------------------------
    #Final function called by the menu in nuke, add a QC switch, a write node and an output
    #param: None
    #return: none
    #--------------------------------------------------

    channels_to_assembly, assembly_choice, render_choice, my_group, sh_beauty, main_channels = assembly()

    dot_final = nuke.nodes.Dot(name = "Dot beauty", xpos = nuke.toNode("fresh alpha")["xpos"].value() + 34, ypos = 2450)
    if assembly_choice == "Additive":
        dot_final.setInput(0, nuke.toNode("fresh alpha"))
    else:
        dot_final.setInput(0, nuke.toNode("premult fresh alpha"))


    merge_qc = nuke.nodes.Merge2(name = "Merge QC", xpos = nuke.toNode("Beauty ref")["xpos"].value(), ypos = nuke.toNode("Dot beauty")["ypos"].value())
    merge_qc["operation"].setValue("difference")
    merge_qc.setInput(1,nuke.toNode("Dot beauty"))
    merge_qc.setInput(0,nuke.toNode("Beauty ref"))

    txt_qc = nuke.nodes.Text2( name = "text_qc", xpos = merge_qc.knob("xpos").value(), ypos = 2550)
    txt_qc.setInput(0, merge_qc)
    txt_qc["box"].setValue((20, 40, 1000, 130))
    txt_qc["font"].setValue("Bahnschrift", "Regular")
    txt_qc["global_font_scale"].setValue(0.2)
    txt_qc["message"].setValue("QC (difference between original beauty and beauty reconstructed)")

    dot_p = nuke.nodes.Dot(name = "Dot preview", xpos = (nuke.toNode("Dot beauty")["xpos"].value() - 200), ypos = 2500  )

    switch_p = nuke.nodes.Switch(name = "Switch preview", xpos = nuke.toNode("Dot beauty")["xpos"].value() - 34, ypos = 2500 )
    switch_p.setInput(0,nuke.toNode("Dot beauty"))
    switch_p.setInput(1,dot_p)

    switch_q = nuke.nodes.Switch(name = "Switch QC", xpos = nuke.toNode("Dot beauty")["xpos"].value() - 34, ypos = 2550 )
    switch_q.setInput(0, nuke.toNode("Switch preview"))
    switch_q.setInput(1, nuke.toNode("text_qc"))
    expression_qc_check = "AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_qc_check_"+render_choice+"_"+assembly_choice
    switch_q["which"].setExpression(expression_qc_check)

    write_b = nuke.nodes.Write(name = "Write beauty_"+render_choice+"_"+assembly_choice, xpos = nuke.toNode("Dot beauty"), ypos = 2650 )
    write_b.setInput(0, nuke.toNode("Switch QC"))
    write_b["channels"].setValue("rgba")

    out = nuke.nodes.Output(name = "Out_AUTO_BEAUTY "+render_choice+" "+assembly_choice, xpos = nuke.toNode("Write beauty_"+render_choice+"_"+assembly_choice)["xpos"].value(), ypos = 2750)
    out.setInput(0,nuke.toNode("Write beauty_"+render_choice+"_"+assembly_choice))







def cycle(assembly_choice, render_choice):
    #--------------------------------------------------
    #Beauty reconstruction based on Cycle passes in additive or substractive
    #param: assembly_choice, render_choice
    #return: main_channels
    #--------------------------------------------------
    nuke.nodes.StickyNote(label = channels_to_assembly)


    main_channels = []

    for item in channels_to_assembly:
        if item == "Emit":
            main_channels.append(item)
        else:
            main_channels.append(item[0:(len(item)-3)])
    main_channels = list(set(main_channels))


    if assembly_choice == "Additive":

        for chan in channels_to_assembly:

            unpremult = nuke.nodes.Unpremult(name = "Unpremult "+chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1300)
            unpremult["channels"].setValue("rgb")
            unpremult["alpha"].setValue("rgba.alpha")
            unpremult.setInput(0,nuke.toNode("Dot "+chan))

            g = nuke.nodes.Grade(name = "Grade "+chan, label = chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1400)
            g.setInput(0, nuke.toNode("Unpremult "+chan))
            g["blackpoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_b_point_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["whitepoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_w_point_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["black"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_lift_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["white"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gain_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["multiply"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_multiply_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["add"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_offset_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["gamma"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gamma_"+render_choice+"_"+assembly_choice+"_"+chan)

            premult = nuke.nodes.Premult(name = "Premult "+chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1500)
            premult["channels"].setValue("rgb")
            premult["alpha"].setValue("rgba.alpha")
            premult.setInput(0,g)


        for chan in main_channels:

            if chan != "Emit":
                m = nuke.nodes.Merge2( name = chan+" addition", xpos = nuke.toNode("Grade "+chan+"Ind")["xpos"].value(), ypos = 1800)
                m.setInput(0, nuke.toNode("Premult "+chan+"Ind"))
                m.setInput(1, nuke.toNode("Premult "+chan+"Dir"))
                m["operation"].setValue("plus")

                m2 = nuke.nodes.Merge2( name = chan+" multiplication", xpos = nuke.toNode(chan+" addition")["xpos"].value(), ypos = 2000)
                m2.setInput(0, nuke.toNode(chan+" addition"))
                m2.setInput(1, nuke.toNode("Premult "+chan+"Col"))
                m2["operation"].setValue("multiply")
            else:
                continue

        m3 = nuke.nodes.Merge2(name = "Merge_output", xpos = nuke.toNode("Diff multiplication")["xpos"].value(), ypos = 2300)
        m3["operation"].setValue("plus")
        i = 0
        for chan in main_channels:
            if i == 2:
                m3.setInput(3,nuke.toNode(chan+" multiplication"))
                i += 1
            elif i == 3:
                m3.setInput(4,nuke.toNode("Premult Emit"))
            else:
                m3.setInput(i,nuke.toNode(chan+" multiplication"))
                i += 1

        c = nuke.nodes.Copy(name = "fresh alpha", xpos = m3.xpos(), ypos = 2380)
        c.setInput(0, m3)
        c.setInput(1,nuke.toNode("render"))
        c["from0"].setValue("rgba.alpha")
        c["to0"].setValue("rgba.alpha")



    else:

        d1 = nuke.nodes.Dot(name = "dot1 to assembly", xpos = nuke.toNode("Beauty ref")["xpos"].value(), ypos = 1250)
        d1.setInput(0,nuke.toNode("Beauty ref"))
        d2 = nuke.nodes.Dot(name = "dot2 to assembly", xpos = (nuke.toNode("Beauty ref")["xpos"].value()-90), ypos = 1250)
        d2.setInput(0,d1)
        u = nuke.nodes.Unpremult(name = "unp all channels", xpos = d2.xpos(), ypos = 1300)
        u.setInput(0,d2)
        u["channels"].setValue("all")

        posY = 1400
        i = 0
        for chan in channels_to_assembly:

            unpremult = nuke.nodes.Unpremult(name = "Unpremult "+chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1300)
            unpremult["channels"].setValue("rgb")
            unpremult["alpha"].setValue("rgba.alpha")
            unpremult.setInput(0,nuke.toNode("Dot "+chan))

            g = nuke.nodes.Grade(name = "Grade "+chan, label = chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1400)
            g.setInput(0, nuke.toNode("Unpremult "+chan))
            g["blackpoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_b_point_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["whitepoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_w_point_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["black"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_lift_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["white"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gain_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["multiply"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_multiply_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["add"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_offset_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["gamma"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gamma_"+render_choice+"_"+assembly_choice+"_"+chan)

            m1 = nuke.nodes.Merge2(name = "Merge sub"+chan, xpos = nuke.toNode("unp all channels")["xpos"].value(), ypos = posY)
            m1.setInput(1,nuke.toNode("Unpremult "+chan))
            if i == 0:
                m1.setInput(0, nuke.toNode("unp all channels"))
            else:
                m1.setInput(0, nuke.toNode("Merge plus"+channels_to_assembly[i-1]))

            m1["operation"].setValue("from")
            m2 = nuke.nodes.Merge2(name = "Merge plus"+chan, xpos = nuke.toNode("unp all channels")["xpos"].value(), ypos = posY + 80 )
            m2.setInput(1,g)
            m2.setInput(0, nuke.toNode("Merge sub"+chan))
            m2["operation"].setValue("plus")

            posY += 100
            i += 1

        r = nuke.nodes.Remove(name = "keep rgb", xpos = nuke.toNode("Merge plusTransInd")["xpos"].value(), ypos = 2380)
        r.setInput(0,nuke.toNode("Merge plusTransInd"))
        r["operation"].setValue("keep")
        r["channels"].setValue("rgb")


        d3 = nuke.nodes.Dot(name = "dot from assembly", xpos = (nuke.toNode("unp all channels")["xpos"].value()+34), ypos = 2400)
        d3.setInput(0,nuke.toNode("keep rgb"))


        c = nuke.nodes.Copy(name = "fresh alpha", xpos = nuke.toNode("render")["xpos"].value(), ypos = 2400)
        c.setInput(0, d3)
        c.setInput(1,nuke.toNode("render"))
        c["from0"].setValue("rgba.alpha")
        c["to0"].setValue("rgba.alpha")

        p = nuke.nodes.Premult(name = "premult fresh alpha", xpos = c.xpos(), ypos = 2420)
        p.setInput(0,c)


    return main_channels









def redshift(assembly_choice, render_choice):
    #--------------------------------------------------
    #Beauty reconstruction based on Redshift passes in additive or substractive
    #param: assembly_choice, render_choice
    #return: main_channels
    #--------------------------------------------------
    nuke.nodes.StickyNote(label = channels_to_assembly)

    main_channels =[]
    for item in channels_to_assembly:
        if "Raw" in item:
            main_channels.append(item[0:(len(item)-3)])
        elif "Filter" in item:
            main_channels.append(item[0:(len(item)-6)])
        elif "Lighting" in item:
            main_channels.append(item[0:(len(item)-8)])
        else:
            main_channels.append(item)

    main_channels = list(set(main_channels))
    main_channels.remove("GI")
    main_channels.remove("DiffuseLighting")



    if assembly_choice == "Additive":

        for chan in channels_to_assembly:

            unpremult = nuke.nodes.Unpremult(name = "Unpremult "+chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1300)
            unpremult["channels"].setValue("rgb")
            unpremult["alpha"].setValue("rgba.alpha")
            unpremult.setInput(0,nuke.toNode("Dot "+chan))

            g = nuke.nodes.Grade(name = "Grade "+chan, label = chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1400)
            g.setInput(0, nuke.toNode("Unpremult "+chan))
            g["blackpoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_b_point_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["whitepoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_w_point_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["black"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_lift_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["white"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gain_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["multiply"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_multiply_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["add"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_offset_"+render_choice+"_"+assembly_choice+"_"+chan)
            g["gamma"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gamma_"+render_choice+"_"+assembly_choice+"_"+chan)


            premult = nuke.nodes.Premult(name = "Premult "+chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1500)
            premult["channels"].setValue("rgb")
            premult["alpha"].setValue("rgba.alpha")
            premult.setInput(0,g)


        m1 = nuke.nodes.Merge2(name = "RefractionsRaw multiply", xpos = nuke.toNode("Premult RefractionsRaw")["xpos"].value(), ypos = 1700)
        m1.setInput(0, nuke.toNode("Premult RefractionsRaw"))
        m1.setInput(1, nuke.toNode("Premult RefractionsFilter"))
        m1["operation"].setValue("multiply")

        m2 = nuke.nodes.Merge2(name = "ReflectionsRaw multiply", xpos = nuke.toNode("Premult ReflectionsRaw")["xpos"].value(), ypos = 1700)
        m2.setInput(0, nuke.toNode("Premult ReflectionsRaw"))
        m2.setInput(1, nuke.toNode("Premult ReflectionsFilter"))
        m2["operation"].setValue("multiply")

        m3 = nuke.nodes.Merge2(name = "DiffuseLightingRaw addition", xpos = nuke.toNode("Premult DiffuseLightingRaw")["xpos"].value(), ypos = 1700)
        m3.setInput(0, nuke.toNode("Premult DiffuseLightingRaw"))
        m3.setInput(1,  nuke.toNode("Premult GIRaw"))
        m3["operation"].setValue("plus")


        m4 = nuke.nodes.Merge2(name = "DiffuseFilter multiply", xpos = m3["xpos"].value(), ypos = 1750)
        m4.setInput(0, m3)
        m4.setInput(1, nuke.toNode("Premult DiffuseFilter"))
        m4["operation"].setValue("multiply")

        m5 = nuke.nodes.Merge2(name = "Emission addition", xpos = m3["xpos"].value(), ypos = 1800)
        m5.setInput(0, m4)
        m5.setInput(1, nuke.toNode("Premult Emission"))
        m5["operation"].setValue("plus")

        m6 = nuke.nodes.Merge2(name = "Reflections addition", xpos = m3["xpos"].value(), ypos = 1850)
        m6.setInput(0, m5)
        m6.setInput(1, m2)
        m6["operation"].setValue("plus")

        m7 = nuke.nodes.Merge2(name = "Refractions addition", xpos = m3["xpos"].value(), ypos = 1900)
        m7.setInput(0, m6)
        m7.setInput(1, m1)
        m7["operation"].setValue("plus")

        m8 = nuke.nodes.Merge2(name = "Specular addition", xpos = m3["xpos"].value(), ypos = 1950)
        m8.setInput(0, m7)
        m8.setInput(1, nuke.toNode("Premult SpecularLighting"))
        m8["operation"].setValue("plus")

        c = nuke.nodes.Copy(name = "fresh alpha", xpos =nuke.toNode("Premult DiffuseFilter"), ypos = 2100)
        c.setInput(0, m8)
        c.setInput(1,nuke.toNode("render"))
        c["from0"].setValue("rgba.alpha")
        c["to0"].setValue("rgba.alpha")


    else:

        for chan in channels_to_assembly:

            unpremult = nuke.nodes.Unpremult(name = "Unpremult "+chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1300)
            unpremult["channels"].setValue("rgb")
            unpremult["alpha"].setValue("rgba.alpha")
            unpremult.setInput(0,nuke.toNode("Dot "+chan))


            if chan == "SpecularLighting" or chan == "Emission":
                g = nuke.nodes.Grade(name = chan, label = chan, xpos = (nuke.toNode("Dot "+chan)["xpos"].value() - 34), ypos = 1600)
                g.setInput(0, nuke.toNode("Unpremult "+chan))
                g["blackpoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_b_point_"+render_choice+"_"+assembly_choice+"_"+chan)
                g["whitepoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_w_point_"+render_choice+"_"+assembly_choice+"_"+chan)
                g["black"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_lift_"+render_choice+"_"+assembly_choice+"_"+chan)
                g["white"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gain_"+render_choice+"_"+assembly_choice+"_"+chan)
                g["multiply"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_multiply_"+render_choice+"_"+assembly_choice+"_"+chan)
                g["add"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_offset_"+render_choice+"_"+assembly_choice+"_"+chan)
                g["gamma"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gamma_"+render_choice+"_"+assembly_choice+"_"+chan)


            lst_raw = ["RefractionsRaw", "ReflectionsRaw"]
            lst_raw2 = ["GIRaw", "DiffuseLightingRaw"]
            main_channels = ['Emission', 'Refractions', 'Specular', 'Reflections', 'Diffuse']
            filters = ["RefractionsFilter", "ReflectionsFilter", "DiffuseFilter"]

            if chan in lst_raw:
                m1 = nuke.nodes.Merge2(name = chan, xpos = nuke.toNode("Unpremult "+chan)["xpos"].value(), ypos = 1500)
                m1.setInput(0, nuke.toNode("Unpremult "+chan[:-3]+"Filter"))
                m1.setInput(1, nuke.toNode("Unpremult "+chan))
                m1["operation"].setValue("divide")
                g1 = nuke.nodes.Grade(name = "Grade "+chan, xpos = nuke.toNode("Unpremult "+chan)["xpos"].value(), ypos = 1550 )
                g1.setInput(0, m1)
                g1["blackpoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_b_point_"+render_choice+"_"+assembly_choice+"_"+chan)
                g1["whitepoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_w_point_"+render_choice+"_"+assembly_choice+"_"+chan)
                g1["black"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_lift_"+render_choice+"_"+assembly_choice+"_"+chan)
                g1["white"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gain_"+render_choice+"_"+assembly_choice+"_"+chan)
                g1["multiply"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_multiply_"+render_choice+"_"+assembly_choice+"_"+chan)
                g1["add"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_offset_"+render_choice+"_"+assembly_choice+"_"+chan)
                g1["gamma"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gamma_"+render_choice+"_"+assembly_choice+"_"+chan)

                m2 = nuke.nodes.Merge2(name = chan[:-3], xpos = nuke.toNode("Unpremult "+chan)["xpos"].value(), ypos = 1600)
                m2.setInput(0, g1)
                m2["operation"].setValue("multiply")
                m2.setInput(1, nuke.toNode("Unpremult "+chan[:-3]+"Filter"))


            if chan in lst_raw2:
                m3 = nuke.nodes.Merge2(name = chan, xpos = nuke.toNode("Unpremult "+chan)["xpos"].value(), ypos = 1500)
                m3.setInput(0, nuke.toNode("Unpremult DiffuseFilter"))
                m3.setInput(1, nuke.toNode("Unpremult "+chan))
                m3["operation"].setValue("divide")
                g2 = nuke.nodes.Grade(name = "Grade "+chan, xpos = nuke.toNode("Unpremult "+chan)["xpos"].value(), ypos = 1550 )
                g2.setInput(0, m3)
                g2["blackpoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_b_point_"+render_choice+"_"+assembly_choice+"_"+chan)
                g2["whitepoint"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_w_point_"+render_choice+"_"+assembly_choice+"_"+chan)
                g2["black"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_lift_"+render_choice+"_"+assembly_choice+"_"+chan)
                g2["white"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gain_"+render_choice+"_"+assembly_choice+"_"+chan)
                g2["multiply"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_multiply_"+render_choice+"_"+assembly_choice+"_"+chan)
                g2["add"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_offset_"+render_choice+"_"+assembly_choice+"_"+chan)
                g2["gamma"].setExpression("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice+".par_gamma_"+render_choice+"_"+assembly_choice+"_"+chan)

                m3 = nuke.nodes.Merge2(name = chan[:-3], xpos = nuke.toNode("Unpremult "+chan)["xpos"].value(), ypos = 1600)
                m3.setInput(0, g2)
                m3["operation"].setValue("multiply")
                m3.setInput(1, nuke.toNode("Unpremult DiffuseFilter"))




        unpr = nuke.nodes.Unpremult(name = "Unpremult assembly", xpos = nuke.toNode("Beauty ref")["xpos"].value()-80, ypos = nuke.toNode("Unpremult DiffuseFilter")["xpos"].value())
        unpr.setInput(0, nuke.toNode("Beauty ref"))
        unpr["channels"].setValue("all")

        #channels_to_assembly = ['DiffuseFilter', 'DiffuseLightingRaw', 'Emission', 'GIRaw', 'ReflectionsFilter', 'ReflectionsRaw', 'RefractionsFilter', 'RefractionsRaw', 'SpecularLighting']
        channels_to_assembly_no_filters = ['DiffuseLightingRaw', 'Emission', 'GIRaw', 'ReflectionsRaw', 'RefractionsRaw', 'SpecularLighting']
        #main_channels = ['Emission', 'Refractions', 'Specular', 'Reflections', 'Diffuse']
        nuke.toNode("Unpremult assembly").setSelected(True)
        for chan in channels_to_assembly_no_filters:

            nuke.createNode("Merge2")['name'].setValue("sub "+chan)
            nuke.toNode("sub "+chan)["operation"].setValue("from")
            nuke.toNode("sub "+chan).setInput(1, nuke.toNode("Unpremult "+chan))


            nuke.createNode("Merge2")['name'].setValue("add "+chan)
            nuke.toNode("add "+chan)["operation"].setValue("plus")
            if "Raw" in chan:
                nuke.toNode("add "+chan).setInput(1, nuke.toNode(chan[:-3]))
            else:
                nuke.toNode("add "+chan).setInput(1, nuke.toNode(chan))




        r = nuke.nodes.Remove(name = "keep rgb", xpos = nuke.toNode("add SpecularLighting")["xpos"].value(), ypos = 2380)
        r.setInput(0,nuke.toNode("add SpecularLighting"))
        r["operation"].setValue("keep")
        r["channels"].setValue("rgb")


        d3 = nuke.nodes.Dot(name = "dot from assembly", xpos = (nuke.toNode("keep rgb")["xpos"].value()+34), ypos = 2400)
        d3.setInput(0,nuke.toNode("keep rgb"))


        c = nuke.nodes.Copy(name = "fresh alpha", xpos = nuke.toNode("render")["xpos"].value(), ypos = 2400)
        c.setInput(0, nuke.toNode("dot from assembly"))
        c.setInput(1,nuke.toNode("render"))
        c["from0"].setValue("rgba.alpha")
        c["to0"].setValue("rgba.alpha")

        p = nuke.nodes.Premult(name = "premult fresh alpha", xpos = c.xpos(), ypos = 2420)
        p.setInput(0,c)


    return main_channels








def visibility():
    #--------------------------------------------------
    #Function called by the knob changed, make some parameters in the denoise and sharpen tab visible or not
    #param: None
    #return: None
    #--------------------------------------------------
    for chan in channels_to_assembly:

        if nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_onOff_den_"+render_choice+"_"+assembly_choice+"_"+chan].value() == True:
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_reg_analys_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(True)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_den_amount_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(True)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_analysis_den_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(True)

        else:
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_reg_analys_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(False)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_den_amount_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(False)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_analysis_den_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(False)


    for chan in channels_to_assembly:

        if nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_onOff_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].value() == True:
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_min_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(True)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_max_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(True)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_sharp_amount_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(True)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_size_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(True)

        else:
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_min_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(False)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_max_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(False)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_sharp_amount_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(False)
            nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_size_sharp_"+render_choice+"_"+assembly_choice+"_"+chan].setVisible(False)







def show_pass():
    #--------------------------------------------------
    #Display the selected pass when button is press in the denoise tab
    #param: None
    #return:None
    #--------------------------------------------------
    pass_select = nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_pass_select_denoise"].value()
    nuke.toNode("Dot preview").setInput(0, nuke.toNode("text_channel_display "+pass_select))
    nuke.toNode("Dot preview")["hide_input"].setValue(True)
    nuke.toNode("Switch preview")["which"].setValue(1)





def show_beauty():
    #--------------------------------------------------
    #Display the beauty pass when button is press in the denoise tab
    #param: assembly_choice, render_choice
    #return: main_channels
    #--------------------------------------------------
    nuke.toNode("Switch preview")["which"].setValue(0)





def analyze_noise_execution():
    #--------------------------------------------------
    #Execute the analysis button in the denoise node
    #param: None
    #return: None
    #--------------------------------------------------
    pass_select = nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice)["par_pass_select_denoise"].value()
    nuke.show(nuke.toNode("Denoise "+pass_select))
    n = nuke.toNode("Denoise "+pass_select)
    n.knob("analyze").execute()
    n.hideControlPanel()
    nuke.show(nuke.toNode("AUTO_BEAUTY_"+render_choice+"_"+assembly_choice))



#def render():
    #nuke.execute(nuke.toNode("Write beauty"))
